# 代码实现

继续接着前文，在经过前面一大堆的设计之后，我们终于可以开始着手代码的实现了。

首先，在最初的实现里，我们写死了把所有的数据存放在 `./data.db` 这个文件里，这种做法当然是不太行的，我们接下来改成由外部传入的一个路径，如果没传的话才用这个作为默认路径。同时定义好涉及到文件结构相关的一些常量，例如文件头的大小，每个页的大小，尾部我们就暂时先不管了：

```ts
const DEFAULT_DB_FILE = './data.db';
const FILE_HEADER_SIZE = 100;
const MAGIC_HEADER_STRING = 'my simpledb format';
const MAGIC_HEADER_SIZE = Buffer.from(MAGIC_HEADER_STRING).length;
const PAGE_SIZE = 4096;
```

其中头部，`FILE_HEADER_SIZE`，我们直接分配 100 个字节，这 100 个字节首先放一个我们自定的 Magic header string，这样先读出来就能知道这个文件是不是我们的数据库创建的，如果不是的话就直接报错。实际上对于一块二进制数据来说，分配一点其中的头部空间用来标识这块数据究竟是干嘛的是个非常常见的做法，尤其在处理文件的时候。

接下来再分配 2 个字节，标识出来数据库每个页的大小，默认值是 4096，当然我们先不做让用户配置页大小的功能，以后有空了再说。剩下的空间，就先空着，等以后需要了再往里面塞东西。

为了保证代码的可读性，接下来我们会使用面向对象的方式来组织我们的代码，我们首先定义一个 `Database` 类：

```ts
class Database {}
```

程序启动时，我们会实例化一个 Database 对象出来，把文件路径传进去，然后对文件的头部进行一下检查，没有问题的话，就可以通过它暴露出的接口来进行读写操作了:

```ts
// 使用命令行用户传入的路径参数或者默认的文件路径
const dbFile = process.argv[2] || DEFAULT_DB_FILE;
const database = new Database(dbFile);

database.open(); // 碰到错误会直接退出

// start repl...
```

读写操作的过程中，每一个页都是一个 B 树节点，从根节点开始进行查找，每次从磁盘上读取一页到内存中，然后根据指针去读取下一页，因为涉及到频繁的从磁盘上读取页这种操作，因此我们会引入一个 `Pager` 对象，通过它提供的接口来进行，后续我们还可以在它其中加入缓存，以优化这个过程。

```ts
class Pager {}

class BTree {}

class BTreeNode {}
```

而在每一个 B 树节点内部，像前一篇文章提到的，他们是由很多个 cell 组成的，因此我们也需要一个 `Cell` 对象来进行抽象。这里我们对这里的 B 树定一个约定，让所有的存储的用户数据都放在最底层的叶子节点，而所有的中间节点我们都只存放指针，这样方便之后进行范围查找，实际上这种做法已经有点像 B+ 树了，只需要让所有的叶子节点连起来变成一个双链表就行了，但为了简单我们先不这么处理，只是单纯约定好中间节点只存放指针。这样就存在两种类型的 Cell，存放指针的，和存放用户数据的：

```ts
class PointerCell {}

class KeyValueCell {}
````

为了查询临近的节点，我们可以先返回到上一级的父节点，再通过父节点存放的指针去访问兄弟节点，这要求我们在遍历时存储一下经过的节点，方便进行回退一步这类操作，因此我们可以引入一个 `Cursor` 对象来进行管理。

```ts
class Cursor {}
```

这样整体的抽象就大概是这样子的：

### 程序启动 

实例化一个 `Database` 对象，检查文件头或者读取一些元数据，通过它提供的 `get`  和 `set` 接口来进行数据的读写。

### `get`

`get` 操作相对来说比较简单：

- 通过 `Cursor` 来查找到键所应该存放的叶子节点 `BTreeNode`；
- 每一次获取 `BTreeNode` 都是通过 `Pager` 读取文件来获得 buffer；
- 找到节点内对应存放值的 `KeyValueCell`；
- 这样就可以把值返回，然后反序列化展示给用户了；

### `set`

`set` 是最复杂的：

- 通过 `Cursor` 来查找到键所应该存放在哪个叶子节点 `BTreeNode`；
- 检查一下这个节点能不能放下我们的数据；
- 如果可以的话，那就直接放进去；
- 如果不行的话，需要进行节点的分裂；
- 先分配一个新的节点；
- 把当前节点后半部分的数据 copy 过去，当前节点只留下前一半数据；
- 通过 `Cursor` 回退到父节点，在父节点中插入指向新节点的指针和分隔键；
- 父节点也要检查能不能放下这个数据，放不下的话再次重复之前的分裂过程；
- 如果根节点都放不下的话，我们将根节点分裂，然后创建一个新的节点作为新的根节点；
- 更新相关的元数据，例如根节点的 id 等等。


## 实现

接下来就开始逐步开始实现我们刚才定义的类。
